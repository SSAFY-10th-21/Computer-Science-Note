# 운영체제

- 프로세스와 스레드
    - 프로세스
        - 메인 메모리(주기억장치)에 적재되어 실행되는 프로그램을 의미합니다.
        - PCB, code, data, heap, stack 영역을 갖습니다.
        - 프로세스별 각각의 영역을 갖기 때문에 별다른 동기화 작업이 필요하지 않습니다.
        - 프로세스별 각각의 영역을 갖기 때문에 context switching 비용이 큽니다.
        - 프로세스 쓰레드보다 무겁기 때문에 생성 시간이 더 깁니다.
        - 한 프로세스에서 오류가 생기더라도 다른 프로세스에 영향을 주지 않습니다.
    - 쓰레드
        - 한 프로세스 내의 실행 단위, 실행의 흐름을 의미합니다.
        - stack 영역만 별도로 갖고, 나머지 영역(code, data, heap)에 대해서는 해당 쓰레드를 포함한 프로세스의 자원을 공유합니다.
        - stack 영역 외부의 공유 자원에 대해 접근 시 동기화 작업이 필요합니다.
        - stack 영역 외부를 공유하므로 컨텍스트 스위칭 비용이 적습니다.
        - 쓰레드는 프로세스보다 가볍기 때문에 생성 시간이 더 짧습니다.
        - 한 쓰레드에서 오류가 생기면, 나머지 프로세스 내의 쓰레드에 영향을 줄 수 있습니다.
- 컴파일 과정
    
    <img width="289" alt="%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-10_%EC%98%A4%ED%9B%84_11 54 56" src="https://github.com/SSAFY-10th-21/Computer-Science-Note/assets/69153087/66e846ab-c3ca-48ac-8208-37c4110ec126">
    

- 프로세스 상태

<img width="289" alt="%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-10_%EC%98%A4%ED%9B%84_11 56 21" src="https://github.com/SSAFY-10th-21/Computer-Science-Note/assets/69153087/1f1adea2-3fae-435a-8eba-98344a9620e1">

- 프로세스의 메모리 구조
    
    ![%EC%BA%A1%EC%B2%98](https://github.com/SSAFY-10th-21/Computer-Science-Note/assets/69153087/39a6637c-ecdc-49da-b7a5-23c3097bdf38)
    
    1. 코드 영역(텍스트 영역) :
    - 실행할 프로그램의 코드가 저장되는 영역으로, '텍스트' 영역이라고도 부릅니다. CPU는 해당 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
    1. 데이터 영역(static 영역) :
    - 전역 변수와 정적 변수가 저장되는 영역으로, 프로그램이 시작하는 동시에 할당되며, 프로그램이 종료되면 소멸합니다.
    1. 힙 영역 (Heap) :
    - 사용자가 직접 관리하는 영역이며 메모리 공간이 동적으로 할당 및 헤제됩니다. 동적으로 할당되므로 new로 생성한 object가 많아질 수록 힙 영역의 크기가 늘어나게 됩니다.
    1. 스택 영역 (Stack) :
    - 함수의 호출에 따른 지역변수와 매개변수가 저장되는 영역으로, 컴파일 시 크기가 결정됩니다. 함수의 호출과 함께 할당되고, 함수의 호출이 종료되면 소멸합니다.
- PCB
    - 프로세스 제어 블록(Process Control Block, 줄여서 PCB)은 프로세스를 관리하기 위한 정보를 포함하는 OS 커널의 자료 구조입니다.
    - OS는 프로세스의 생성과 동시에 고유한 PCB 를 생성합니다.
    - PCB가 프로세스의 중요한 정보를 포함하고 있기 때문에, 일반 사용자가 접근하지 못하도록 보호된 메모리 영역 안에 위치합니다.
    - 프로세스는 수행할 차례가 되면, CPU를 할당받아 작업을 처리합니다. 작업을 처리하던 도중 프로세스의 시간이 모두 경과되거나 인터럽트가 발생하는 등의 프로세스 전환이 발생하면, 진행하던 작업을 저장하고 CPU 를 반환합니다. 이 때, 수행하던 프로세스 관련 데이터들을 PCB 에 저장합니다. 그리고 다시 프로세스의 수행 차례가 와서 CPU 를 할당받게 되면, PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행합니다. 이렇게 사용하던 프로세스의 데이터를 PCB에 저장하고, 실행할 프로세스의 데이터를 PCB에서 불러오는 과정을 Context Switching 이라고 합니다.
    - PCB 에 저장되는 정보는 아래와 같습니다.
        - **프로세스 식별자(Process ID, PID)** : 프로세스 식별번호
        - **프로세스 상태** : new, ready, running, waiting, terminated 등의 상태를 저장
        - **프로그램 카운터** : 프로세스가 다음에 실행할 명령어의 주소
        - **CPU 레지스터 :** 프로세스를 실행하기 위해 저장해야 할 레지스터의 정보
        - **CPU 스케쥴링 정보** : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
        - **메모리 관리 정보** : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
        - **입출력 상태 정보** : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
        - **어카운팅 정보** : 사용된 CPU 시간, 시간제한, 계정번호 등
- context switching
    - 문맥교환(context switching)은, 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스 혹은 쓰레드)의 상태를 PCB에 저장하고, 다음에 진행할 Task의 상태 값을 읽어 레지스터에 적재하는 과정을 의미합니다.
        1. CPU가 다른 프로세스로 전환하면 시스템은 프로세스의 상태를 PCB에 저장합니다
        2. 대기열에서 다음 프로세스를 선택하고 해당 프로세스의 PCB를 복원합니다.
        3. PCB의 프로그램 카운터(레지스터)가 로드되어 이전까지 작업한 곳의 지점으로 돌아가 선택한 프로세스의 작업을 이어서 합니다.
- 멀티 프로세싱
    1. 멀티 쓰레드
    - 하나의 프로세스를 여러 개의 쓰레드로 구성해 자원을 공유하면서 작업을 수행하는 것을 의미합니다.
    - 멀티 프로세스보다 적은 메모리 공간을 차지하고, Context Switching이 빠른 장점이 있지만, 오류로 인해 하나의 쓰레드가 종료되면 전체 쓰레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있습니다.
    1. 멀티 프로세스
    - 하나의 프로그램을 여러개의 프로세스로 구성해 프로세스가 병렬적으로 작업을 수행하는 것입니다.
    - 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않지만, 멀티 쓰레드보다 많은 메모리 공간을 차지합니다.
    
    왜 멀티 쓰레드를 더 많이 사용하는가?
    
    - 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이고, Context Switching 시, Stack 영역만 초기화하면 되기 때문에 더 빠릅니다. 프로세스 생성시 자원 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있는 장점도 있습니다.
- 공유자원과 임계영역
    - 공유자원
        - 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수 등을 의미합니다.
        - 두 개 이상의 프로세스가 동시에 공유 자원을 읽거나 쓰는 상황을 경쟁 상태(race condition)이라고 합니다.
    
    <img width="385" alt="%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-10_%EC%98%A4%ED%9B%84_11 59 31" src="https://github.com/SSAFY-10th-21/Computer-Science-Note/assets/69153087/9c0b6cd9-0c92-47ec-9052-cd2792155be5">
    
    - 임계영역
        - 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
    - 뮤텍스
        
        <img width="452" alt="%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-11_%EC%98%A4%EC%A0%84_12 02 27" src="https://github.com/SSAFY-10th-21/Computer-Science-Note/assets/69153087/e4699638-9c47-4f72-b077-476d53593cc8">
        
        - **오직 1개만의 스레드(또는 프로세스)만 접근** 할 수 있다.
        - 1개만 접근 가능하므로 반드시 락을 획득한 프로세스가 락을 해제해야 한다. ⇒ **락에 대한 소유권이 있음**
        - **예시**
            
            일부 음식점들은 `공용 화장실(공유 자원)` 관리 차원에서 화장실을 잠궈두고(`Locking`) 다닙니다. 손님들이 화장실에 가려면 주인에게 `열쇠(Lock)`를 받은 후 가야합니다. 물론 다음 손님이 `공용 화장실(공유 자원)`에 가려면 앞 손님이 `열쇠(Lock)`를 반납해야 갈 수 있습니다.
            
            이렇게 `열쇠(Lock)`를 가지고 있는 경우에만 `공유자원(화장실)`에 접근할 수 있습니다. 이게 바로 `뮤텍스(Mutex)`라고 보면 됩니다. 유의할 점은 `Lock`에 대한 소유권이 있다는 점입니다. 열쇠를 획득한 사람만 반납할 수 있습니다.
            
    - 세마포어
        - **세마포어 변수만큼의 스레드(또는 프로세스)가 접근** 할 수 있다.
        - 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다.
        - 이진 세마포어는 뮤텍스와 동일하다고 볼 수 있다. 이진 세마포어가 아닌 나머지 세마포어를 카운팅 세마포어라고 부른다.
        - **예시**
            
            `107호 병실(임계 구역)`에 `방문객용 의자가 5개(임계구역 안의 자원)` 있다고 했을 때, `간호사(세마포어)`는 이 **병실에 방문자가 5명(Counter 개수)만 들어갈 수 있도록 허용**하고 나머지 방문객들은 밖에서 대기하도록 합니다. `Counter 개수`만큼 `임계 구역(병실)`에 접근할 수 있습니다.
            
            이 `세마포어 Counter의 개수에 따라` 1개의 경우 `이진 세마포어(Binary Semaphore)`, 2개 이상의 경우 `카운팅 세마포어(Counting Semaphore)`라고 불립니다. `Binary Semaphore`의 경우 개념적으로 `Mutex`와 같다고 볼 수 있습니다.
            
        - **의문점**
            
            `상호배제(Mutual Exclusion)`를 생각해보면, `카운팅 세마포어(Counting Semaphore)`가 이상해 보입니다. 분명 **하나의 자원에는 하나의 프로세스만 접근**할 수 있기 때문입니다. 그렇다면 카운팅 세마포어는 상호 배제를 깨는 것일까요??
            
            맞습니다. 다만, 상호 배제를 깨는건 맞는데 제한적으로 그러니까 **임계값 만큼이 동시에 깰 수 있게 됩니다.**
            
            위의 병실을 예를 들어 설명해보자면,
            
            `임계구역(병실)`에 `1이라는 자원(의자 1개)`만 있는데 이 `1(의자)`을 사용하는 `스레드(방문자)`가 여러개가 된다는 것이 아니라, `1,2,3,4,5라는 자원(의자 5개)`을 `5개의 스레드(5명의 방문자)`가 사용하게 되는 것입니다.
            
            즉, **임계구역은 상호 배제를 깨게 되지만, 자원 자체에서는 상호 배제를 유지**할 수 있는 것입니다.
            
    - 모니터
        
        <img width="452" alt="%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-11_%EC%98%A4%EC%A0%84_12 04 34" src="https://github.com/SSAFY-10th-21/Computer-Science-Note/assets/69153087/721e12f6-52ef-4968-b1cd-f491753bcd7b">
        
- [https://dev-splin.github.io/cs(computer science)/operating system/OS-Mutex,Semaphore,Monitor/](https://dev-splin.github.io/cs(computer%20science)/operating%20system/OS-Mutex,Semaphore,Monitor/)

- 교착 상태
    - DeadLock(교착상태)는, 두 개 이상의 프로세스나 쓰레드가 서로 자원을 기다리면서 무한히 대기하는 상태를 의미합니다.
        
        DeadLock이 발생하기 위한 조건은 4가지가 있습니다.
        
        - 상호 배제 (Mutual Exclusion) : 한 자원에 여러 프로세스가 동시에 접근할 수 없다.
        - 점유 대기 (Hold and Wait) : 하나의 자원을 소유한 상태에서 다른 자원을 기다린다.
        - 비선점 (Non-preemption) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 프로세스의 자원을 뺏을 수 없다.
        - 순환 대기 (Circular Wait) : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.
    - 교착 상태 해결 방법
        - 예방(Prevention)
            - 교착 상태 조건 중 **하나를 제거함**으로 데드락이 발생하지 않도록 예방하는 방식
            - 자원 낭비가 심하다.
        - 회피(Avoidance)
            - **데드락 발생 가능성을 인정하면서도 적절하게 회피하는 방식**
            - 은행원 알고리즘
                - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하는 알고리즘
                - 발생하지 않으면 자원을 할당하고, 발생하면 다른 프로세스가 자원을 해제할 때까지 대기한다.
                - 안전상태: 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태
                - 항상 안전 상태를 유지할 수 있다는 장점이 있으나 최대 자원 요구량을 미리 알아야 하고 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.
        - 회복(Recovery)
            - 은행원 알고리즘과 유사하게 시스템의 자원 할당 상태를 갖고 데드락이 발생했는지 여부를 탐색한다.
            - 탐지했다면 데드락을 회복한다.
                - 데드락 상태의 프로세스 모두 중단시키기
                - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키기
                - 자원 섬점을 통해 해결하기(교착 상태에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에 할당)
- CPU 스케줄링 알고리즘
    - 준비 큐에 있는 프로세스 중, 다음에 CPU를 할당할 프로세스를 선택하는 알고리즘을 CPU Scheduling이라고 합니다.
    
    <비선점> 
    
    프로세스가 스스로 CPU 소유권을 포기하는 방식으로 강제로 프로세스를 중지 하지 않음
    
    - First Come First Served(FCFS)
        - 큐에 도착한 순서대로 실행
        - 최악의 경우 오래 걸리는 문제가 가장 먼저 들어옴
    - Shortest Job First (SJF)
        - CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식
        - **기아 문제** 발생 → 긴 실행 시간을 가진 프로세스는 CPU를 계속 할당 받지 못함
    - 우선순위
        - 기존 SJF 스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상 발생
        - 오래된 작업일수록 ‘우선순위를 높이는 방법(aging)’올 통해 단점을 보완 한 알고리즘을 말합니다.
    
    <선점>
    
    강제로 다른 프로세스에 CPU 소유권을 할당하는 방식
    
    - Round Robin(RR)
        - **매 프로세스에 시간 할당량을 주고 할당된 시간 안에 완료하지 못한 프로세스는 레디 큐의 맨 뒤에 배치하는 방식**
    - Shortest Remaining Time First (SRTF)
        - **CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 빙식**
        - 증간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘
        - SJF 방식에서 선점 방식만 다르다고 보면 된다.
        - **기아 문제** 발생
    - 다단계 큐
        - 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용한 것을 말합니다.